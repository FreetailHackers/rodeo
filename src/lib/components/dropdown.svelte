<script lang="ts">
	import Select from 'svelte-select';
	import fuzzysort from 'fuzzysort';

	interface Props {
		name: string;
		id?: string;
		items: string[];
		custom: boolean;
		multiple: boolean;
		value: string;
		json?: boolean;
		class?: string;
		onInput?: (event: CustomEvent) => void;
	}

	let {
		name,
		id = name,
		items,
		custom = false,
		multiple = false,
		value = $bindable(),
		json = false,
		class: className,
		onInput,
	}: Props = $props();

	// KEEP THESE
	// name: string; Name for the input
	// id = name; ID for the input
	// items: string[]; // Items to display in the dropdown
	// custom = false; // Whether to allow custom values
	// multiple = false; // Whether to allow multiple values
	// value: string; // Value of the dropdown
	// json = false; // Whether to parse the value as JSON (mainly useful for GET forms)

	let filterText = $state('');
</script>

<Select
	{id}
	{name}
	class={className}
	itemFilter={(label, filterText) =>
		filterText === '' || fuzzysort.go(filterText, [label]).length > 0}
	items={custom && filterText ? [...new Set([...items, filterText])] : items}
	bind:filterText
	on:input={(event) => {
		// Manually update search variable because binding it to justValue along with
		// defining an expression for value causes an infinite loop for some reason ðŸ˜­ðŸ˜­ðŸ˜­
		if (!event.detail) {
			value = '';
		} else if (!multiple) {
			value = event.detail;
		}
		if (json) {
			value = JSON.stringify(value);
		}
		if (onInput) {
			onInput(event);
		}
	}}
	value={(() => {
		if (!json) {
			return value;
		}
		// Ugly but this is the easiest way I found to populate the dropdown that works when
		// you refresh the page
		try {
			return JSON.parse(value);
		} catch (e) {
			return '';
		}
	})()}
	{multiple}
	closeListOnChange={!multiple}
	containerStyles="border: 2px solid gray; border-radius: 0; margin-top: 0px; min-height: 2.5rem; min-width: 60%"
	inputStyles="margin: 0;"
>
	<!-- Horrible hack to make svelte-select submit just the values without the container object -->
	<div slot="input-hidden" let:value>
		<input
			type="hidden"
			{name}
			value={(() => {
				if (multiple) {
					return Array.isArray(value) ? JSON.stringify(value.map((item) => item.value)) : '';
				}
				return value ? JSON.stringify(value.value) : '';
			})()}
		/>
	</div>
	<div slot="item" let:item>
		{items.includes(item.label) ? '' : 'Other: '}
		{item.label}
	</div>
</Select>
